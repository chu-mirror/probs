## A simple C program

This extension defines the structure of a simple C program.

@[c code@]
@{includes@}
@{macros@}
@{data@}
@{prototypes@}
@{functions@}
@

Some conventional header files.
@[includes@]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
@

You must have it, right?
@[c code@]
int
main(int argc, char *argv[])
{
	@{initialize environment@}
	@{main@}
}
@

Some algorithms are randomized.
@[initialize environment@]
srand(19990721); /* my birthday */
@

## Selected Algorithms

This section introduces some useful algorithms so that I don't have to
write them once by once.  The interface of these algorighms are very strict,
they are not supposed to be used outside of this framework after all.

The algorithms use global variables to interact with callers.  The main one is
an array named _values_, sorts or some other algorithms based on randomly accessing use it.
I will try my best to do not use pointers and manage memory by _malloc_ and _free_.

@[macros@]
#define MAXSIZE (100000 + 100)
@

@[data@]
typedef int pos_t; /* position type */
int values[MAXSIZE];
int size;
@

Some algorithms require comparing between values, you can define your own macro _KEY_
to overide this definition.
@[macros@]
#ifndef KEY
#define KEY(p) (values[p])
#endif
@

Auxilialary functions.
@[functions@]
void swap(pos_t p1, pos_t p2)
{
	int t = values[p1];
	values[p1] = values[p2];
	values[p2] = t;
}
@

@[prototypes@]
void swap(pos_t, pos_t);
@


### Quick Sort

quicksort: sort values[l..r)

Always use values[l] as pivot.
@[functions@]
void quicksort(pos_t l, pos_t r)
{
	if (r - l < 2) return;

	@{choose a random pivot@}

	{ pos_t pl, pr;
		@{divide values by pivot [pl, pr)@}
		quicksort(l, pl);
		quicksort(pr, r);
	}
}
@

@[prototypes@]
void quicksort(pos_t, pos_t);
@

@[choose a random pivot@]
{ pos_t rp;
	rp = rand()%(r-l) + l;
	swap(rp, l);
}
@

Fixed point:
values[p1..p2) < values[l]
values[p2..p3) == values[l]
values[p3..r) > values[l]

@[divide values by pivot [pl, pr)@]
{ pos_t p1, p2, p3;
	p1 = p2 = p3 = r;
	while (p1 - l) {
		p1--;
		if (KEY(p1) == KEY(l)) {
			swap(p1, --p2);
		} else if (KEY(p1) > KEY(l)) {
			swap(p1, --p2);
			swap(p2, --p3);
		}
	}
	pl = p2;
	pr = p3;
}
@

