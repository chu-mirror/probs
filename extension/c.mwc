## A simple C program

This extension defines the structure of a simple C program.

@[c code@]
@{includes@}
@{macros@}
@{data@}
@{prototypes@}
@{functions@}
@

Some conventional header files.
@[includes@]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
@

You must have it, right?
@[c code@]
int
main(int argc, char *argv[])
{
	@{initialize environment@}
	@{main@}
}
@

Some algorithms are randomized.
@[initialize environment@]
srand(19990721); /* my birthday */
@

## Basic Data Structures

### Random Access Collection

The algorithms of next section use global variables to interact with callers.  The main one is
an array named _values_, sorts or some other algorithms based on random accessing use it.
I will try my best to do not use pointers and manage memory by _malloc_ and _free_.

@[macros@]
#define MAXSIZE (100000 + 100)
@

@[data@]
typedef int pos; /* position type */
int values[MAXSIZE];
int size;
@

Some algorithms require comparing between values, you can define your own macro _KEY_
to overide this definition.
@[macros@]
#ifndef KEY
#define KEY(v) (v)
#endif
@

@[functions@]
void swap(pos p1, pos p2)
{
	int t = values[p1];
	values[p1] = values[p2];
	values[p2] = t;
}
void append(int v)
{
	values[size++] = v;
}
@

@[prototypes@]
void swap(pos, pos);
void append(int);
@
### List

The list used in this framework is inspired by _Lisp_.

@[data@]
typedef struct listnode {
	int v; /* value */
	struct listnode *n; /* previous, next node */
} lnode, *list_t;
@

@[functions@]
list_t cons(int v, list_t l)
{ lnode *np;
	np = calloc(1, sizeof(lnode));
	np->v = v;
	np->n = l;
	return np;
}

int car(list_t l)
{
	return l->v;
}

list_t cdr(list_t l)
{
	return l->n;
}
@

@[prototypes@]
list_t cons(int, list_t);
int car(list_t);
list_t cdr(list_t);
@

Because we do not have garbege collection in _C_, we should release memory manually.
@[functions@]
void decons(list_t l)
{
	while (l) { list_t t = l;
		l = cdr(l);
		free(t);
	}
}
@

@[prototypes@]
void decons(list_t);
@

### Hash Table

I use prime 100003 to hash values.

@[functions@]
int hash(int k)
{
	return k % 100003;
}
@

The hash table is built upon list defined above.
@[data@]
list_t htable[MAXSIZE];
@

So you should explain lnode.v yourself.
@[macros@]
#ifndef HKEY
#define HKEY(v) (v)
#endif

#ifndef HVAL
#define HVAL(v) (v)
#endif
@

Searching is relatively important.
@[functions@]
list_t hsearch(int k)
{ list_t l;
	l = htable[hash(k)];
	while (l) {
		if (k == HKEY(car(l))) break;
		l = cdr(l);
	}
	return l;
}

int hvalue(int k)
{ list_t l = hsearch(k);
	return HVAL(car(l));
}
@

@[prototypes@]
list_t hsearch(int);
int hvalue(int);
@

@[functions@]
void hinsert(int v)
{ int h = hash(HKEY(v));
	htable[h] = cons(v, htable[h]);
}
@

@[prototypes@]
void hinsert(int);
@

## Selected Algorithms

This section introduces some useful algorithms so that I don't have to
write them once by once.  The interface of these algorighms are very strict,
they are not supposed to be used outside of this framework after all.


### Quick Sort

quicksort: sort values[l..r)

Always use values[l] as pivot.
@[functions@]
void quicksort(pos l, pos r)
{
	if (r - l < 2) return;

	@{choose a random pivot@}

	{ pos pl, pr;
		@{divide values by pivot [pl, pr)@}
		quicksort(l, pl);
		quicksort(pr, r);
	}
}
@

@[prototypes@]
void quicksort(pos, pos);
@

@[choose a random pivot@]
{ pos rp;
	rp = rand()%(r-l) + l;
	swap(rp, l);
}
@

Fixed point:
values[p1..p2) < values[l]
values[p2..p3) == values[l]
values[p3..r) > values[l]

@[divide values by pivot [pl, pr)@]
{ pos p1, p2, p3;
	p1 = p2 = p3 = r;
	while (p1 - l) {
		p1--;
		if (KEY(values[p1]) == KEY(values[l])) {
			swap(p1, --p2);
		} else if (KEY(values[p1]) > KEY(values[l])) {
			swap(p1, --p2);
			swap(p2, --p3);
		}
	}
	pl = p2;
	pr = p3;
}
@

