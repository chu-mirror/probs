The following is a simple test framework for programs whose behaviour
can be well specified by standard input and output.  The framework
generate a corresponding _ruby_ script for each tested program.

@[test@]
#!/usr/bin/ruby

@{classes@}
@{run tests@}
@

You should organize your sample data as:
```
===
<input1>
>>>
<output2>
===
<input2>
>>>
<output2>
```

for example, you can test a program reading in two numbers and
write out their sum as:
```
===
1 1
>>>
2
```

@[classes@]
class Sample
	SAMPLE_SEP = /\n===\n/m
	INPUT_OUTPUT_SEP = /\n>>>\n/m

	attr_reader :input, :output

	def self.parse(samples)
		samples.split(SAMPLE_SEP)[1..-1]
		       .map {|s| self.new(s.rstrip)}
	end

	def initialize(sample)
		@input, @output = sample.split(INPUT_OUTPUT_SEP)
	end
end
@

@[classes@]
class TestPoint
	def initialize(f)
		@file = f
	end
	
	def run_test(sample)
		open("|#{@file}", "r+") do |e|
			e.puts sample.input; e.close_write
			(r = e.readlines.map{|l| l.rstrip}.join("\n")) == sample.output ? nil : r;
		end
	end
end
@

The framework assumes that the names of a program being tested and the
corresponding test script have a relation of "*" "*.test".
@[run tests@]
samples = Sample.parse <<SAMPLES

@{samples@}

SAMPLES

tested = TestPoint.new(__FILE__.sub(/\.test/, ""))

i = 0
samples.each do |s|
	i += 1
	tested.run_test(s).tap do |x|
		if x; puts "test #{i} didn't pass\n"
			open("input#{i}", "w").puts s.input
			open("output#{i}", "w").puts s.output
			open("result#{i}", "w").puts x
		end
	end
end
@

